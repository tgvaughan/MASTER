/*
 * Copyright (C) 2012 Tim Vaughan <tgvaughan@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package master.outputs;

import beast.base.core.Description;
import master.InheritanceEnsemble;
import master.InheritanceTrajectory;
import master.model.Node;
import master.model.Population;

/**
 * Class containing static methods useful for exporting tree-like graphs
 * using the NEXUS format.  An advantage of this format over the vanilla
 * Newick format is that it allows annotations describing the population
 * type and location of each node.
 * 
 * <p>Note that extended newick strings will be used if the graph is not
 * tree-like in the direction it's traversed.</p>
 *
 * @author Tim Vaughan <tgvaughan@gmail.com>
 */
@Description("Output writer capable of writing inheritance graph to"
        + " disk in NEXUS format.  Note that in the case that the graph is"
        + " not tree-like, an annotated variant of the extended Newick format"
        + " of Cardona et al, BMC Bioinf. (2008) is used in place of the"
        + " traditional annotated Newick for the topology strings.")
public class NexusOutput extends NewickOutput {
    
    public NexusOutput() { }
    
    @Override
    public void write(InheritanceTrajectory itraj) {
        
        if (itraj.getSpec().getVerbosity()>0)
            System.out.println("Writing NEXUS output...");
        
        pstream.println("#nexus\n\nBegin trees;");
        
        // Skip empty inheritance graphs:
        if (!itraj.getStartNodes().isEmpty()) {
            pstream.print("tree TREE = ");
            generateOutput(itraj);
        } else {
            if (itraj.getSpec().getVerbosity()>0)
                System.out.println("Warning: NEXUS writer skipping empty graph.");
        }
        
        pstream.println("End;");
    }

    @Override
    public void write(InheritanceEnsemble iensemble) {
        
        if (iensemble.getSpec().getVerbosity()>0)
            System.out.println("Writing NEXUS output...");
                
        pstream.println("#nexus\n\nBegin trees;");
        
        int skips = 0;
        for (int i=0; i<iensemble.getTrajectories().size(); i++) {
            InheritanceTrajectory thisTraj = iensemble.getTrajectories().get(i);
            
            // Skip empty inheritance graphs:
            if (!thisTraj.getStartNodes().isEmpty()) {
                pstream.print("tree TREE_" + i + " = ");
                generateOutput(thisTraj);
            } else {
                skips += 1;
                if (iensemble.getSpec().getVerbosity()>0)
                    System.out.print("\rWarning: NEXUS writer skipping empty "
                            + "graph. (repeated " + skips + " times)");
            }
        }
        pstream.println("End;");
        
        if (iensemble.getSpec().getVerbosity()>0 && skips>0)
            System.out.println();
    }

    @Override
    protected void addLabel(Node node, Population edgePop, double branchLength) {
        
        if (leafLabels.containsKey(node))
            pstream.append(leafLabels.get(node));
        
        if (hybridIDs.containsKey(node))
            pstream.append("#").append(String.valueOf(hybridIDs.get(node)));
        // note that we've omitted the optional "type" specifier

        // Annotations traditionally refer to the branch _above_ the node
        // on the tree.  The following correction ensures this tradition is
        // followed when a tree is generated by reading a graph in reverse.

        pstream.append("[&");
        pstream.format("type=\"%s\"", edgePop.getType().getName());
        if (!edgePop.isScalar()) {
            pstream.append(",location=\"");

            int[] loc = edgePop.getLocation();
            for (int i=0; i<loc.length; i++) {
                if (i>0)
                    pstream.append(" ");
                pstream.append(String.valueOf(loc[i]));
            }
            
            pstream.append("\"");
        }
        if (node.getReaction() != null && node.getReaction().getName() != null)
            pstream.format(",reaction=\"%s\"", node.getReaction().getName());
        pstream.append(",time=").append(String.valueOf(node.getTime()));
        
        // Add general annotations:
        if (node.getAttributeNames() != null) {
            for (String name : node.getAttributeNames()) {
                Object value = node.getAttribute(name);
                
                if (value instanceof Integer) {
                    pstream.append("," + name + "=" + String.valueOf((Integer)value));
                    continue;
                }
                
                if (value instanceof Double) {
                    pstream.append("," + name + "=" + String.valueOf((Double)value));
                    continue;
                }
                                
                if (value instanceof Boolean) {
                    pstream.append("," + name + "=" + String.valueOf((Boolean)value));
                    continue;
                }
                                
                if (value instanceof String) {
                    pstream.append("," + name + "=" + (String)value);
                    continue;
                }
            }
        }
        
        pstream.append("]");
        
        pstream.append(":").append(String.valueOf(branchLength));
    }
}
